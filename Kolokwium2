Zad 1 Rozważmy napis w formie danych osobowych składających się z imienia i nazwiska pisanych dużymi literami oddzielonych spacją. KAMIL NOWAK. Napisać funkcję, która zwraca napis o jednym argumencie będącym napisem. Funkcja modyfikuje napis z argumentu zmieniając go do formatu, w którym imię jest oddzielone od nazwiska kropką oraz tylko pierwsze ich litery są duże. Wynikiem dla podanego przykładu będzie Kamil.Nowak.

#include <stdio.h>
#include <ctype.h>

void formatujDaneOsobowe(char* daneOsobowe) {
    // Zmienia pierwsze litery imienia i nazwiska na duże litery
    for (int i = 0; daneOsobowe[i] != '\0'; i++) {
        if (i == 0 || daneOsobowe[i-1] == ' ') {
            daneOsobowe[i] = toupper(daneOsobowe[i]);
        } else {
            daneOsobowe[i] = tolower(daneOsobowe[i]);
        }
    }

    // Zamienia spację na kropkę między imieniem i nazwiskiem
    for (int i = 0; daneOsobowe[i] != '\0'; i++) {
        if (daneOsobowe[i] == ' ') {
            daneOsobowe[i] = '.';
            break;
        }
    }
}

int main() {
    char daneOsobowe[] = "KAMIL NOWAK";
    formatujDaneOsobowe(daneOsobowe);
    printf("%s\n", daneOsobowe);
    return 0;
}

Zad 2
Napisać funkcję, która zwraca napis o jednym argumencie będącym napisem. Funkcja modyfikuje napis z argumentu w taki sposób, że jeśli małe litery a i b stoją w nim obok siebie to oddziela je dużą literą W wstawiając ją pomiędzy. Czynność tą wykonuje dla każdego takiego wystąpienia.
Np. dla napisu doba, zwrócony ma zostać dobWa;
Np. dla napisu abazur, zwrócony ma zostać aWbWazur;
Np. dla napisu baba, zwrócony ma zostać bWaWbWa;
Np. dla napisu baobab, zwrócony ma zostać bWaobWaWb;

#include <stdio.h>
#include <string.h>

void modifyString(char* input) {
    int length = strlen(input);
    int newSize = length * 2 + 1; // Nowy rozmiar napisu (z uwzględnieniem dodanych liter 'W' i zakończenia '\0')
    char result[newSize]; // Nowy napis wynikowy

    int j = 0; // Indeks dla napisu wynikowego

    for (int i = 0; i < length; i++) {
        // Dodawanie oryginalnej litery do napisu wynikowego
        result[j++] = input[i];

        // Sprawdzanie warunku wystąpienia małych liter obok siebie
        if (i < length - 1 && input[i] >= 'a' && input[i] <= 'z' && input[i + 1] >= 'a' && input[i + 1] <= 'z') {
            // Dodawanie dużej litery 'W' do napisu wynikowego
            result[j++] = 'W';
        }
    }

    // Dodanie zakończenia napisu
    result[j] = '\0';

    // Kopiowanie napisu wynikowego z powrotem do napisu wejściowego
    strcpy(input, result);
}

int main() {
    char input[] = "baobab";
    printf("Przed: %s\n", input);
    modifyString(input);
    printf("Po: %s\n", input);

    return 0;
}

Zad 3
a) Napisz funkcję, która otrzymuje w argumencie kwadratową tablicę elementów typu int oraz jej wymiar i zwraca ślad przekazanej w argumencie macierzy. Ślad to suma elementów na głównej przekątnej macierzy.
b) Napisz funkcję, która otrzymuje w argumencie dodatnie liczby całkowite m i n oraz dwuwymiarową tablicę tablic elementów typu int. Funkcja ma obliczyć sumę wszystkich elementów parzystych macierzy przekazanej w argumencie, znajdujących się na jej brzegu, to jest w pierwszym lub ostatnim wierszu lub pierwszej lub ostatniej kolumnie.
a)
#include <stdio.h>

int trace(int matrix[][100], int size) {
    int i, sum = 0;
    
    for (i = 0; i < size; i++) {
        sum += matrix[i][i];
    }
    
    return sum;
}

int main() {
    int matrix[100][100];
    int size, i, j;
    
    printf("Podaj wymiar macierzy kwadratowej: ");
    scanf("%d", &size);
    
    printf("Podaj elementy macierzy:\n");
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }
    
    int result = trace(matrix, size);
    
    printf("Ślad macierzy: %d\n", result);
    
    return 0;
}
b)
#include <stdio.h>

int sumOnBorder(int matrix[][100], int m, int n) {
    int i, j, sum = 0;
    
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                if (matrix[i][j] % 2 == 0) {
                    sum += matrix[i][j];
                }
            }
        }
    }
    
    return sum;
}

int main() {
    int matrix[100][100];
    int m, n, i, j;
    
    printf("Podaj liczbę wierszy macierzy: ");
    scanf("%d", &m);
    
    printf("Podaj liczbę kolumn macierzy: ");
    scanf("%d", &n);
    
    printf("Podaj elementy macierzy:\n");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }
    
    int result = sumOnBorder(matrix, m, n);
    
    printf("Suma elementów parzystych na brzegu macierzy: %d\n", result);
    
    return 0;
}

Zad 4
a) Napisać funkcję, która dostaje jako argumenty tablicę dwuwymiarową o elementach typu int oraz jej wymiary i odwraca kolejność we wszystkich kolumnach otrzymanej tablicy.
b) Napisz funkcję, która dostaje jako argumenty tablicę dwuwymiarową o elementach typu int oraz jej wymiary i zmienia kolejność kolumn przesuwając je o dwa w prawo w tablicy w taki sposób, że kolumna pierwsza ma się znaleźć na miejscu trzeciej, kolumna druga na miejscu czwartej itd., natomiast ostatnia kolumna ma się znaleźć na miejscu drugiej, a przedostatnia na miejscu pierwszej

#include <stdio.h>

void odwrocKolumny(int tablica[][5], int wiersze, int kolumny) {
    for (int j = 0; j < kolumny; j++) {
        int i = 0;
        int k = wiersze - 1;
        while (i < k) {
            int temp = tablica[i][j];
            tablica[i][j] = tablica[k][j];
            tablica[k][j] = temp;
            i++;
            k--;
        }
    }
}

void przesunKolumny(int tablica[][5], int wiersze, int kolumny) {
    int temp[kolumny];
    for (int i = 0; i < wiersze; i++) {
        for (int j = 0; j < kolumny; j++) {
            temp[(j + 2) % kolumny] = tablica[i][j];
        }
        for (int j = 0; j < kolumny; j++) {
            tablica[i][j] = temp[j];
        }
    }
}

void wyswietlTablice(int tablica[][5], int wiersze, int kolumny) {
    for (int i = 0; i < wiersze; i++) {
        for (int j = 0; j < kolumny; j++) {
            printf("%d ", tablica[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main() {
    int tablica[4][5] = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}
    };

    printf("Tablica przed odwróceniem kolumn:\n");
    wyswietlTablice(tablica, 4, 5);

    odwrocKolumny(tablica, 4, 5);

    printf("Tablica po odwróceniu kolumn:\n");
    wyswietlTablice(tablica, 4, 5);

    printf("Tablica przed przesunięciem kolumn:\n");
    wyswietlTablice(tablica, 4, 5);

    przesunKolumny(tablica, 4, 5);

    printf("Tablica po przesunięciu kolumn:\n");
    wyswietlTablice(tablica, 4, 5);

    return 0;
}
================
#include <stdio.h>

void reverseColumns(int arr[][3], int rows, int cols) {
    for (int j = 0; j < cols; j++) {
        int start = 0;
        int end = rows - 1;
        while (start < end) {
            int temp = arr[start][j];
            arr[start][j] = arr[end][j];
            arr[end][j] = temp;
            start++;
            end--;
        }
    }
}

void shiftColumns(int arr[][4], int rows, int cols) {
    for (int j = 0; j < cols / 2; j++) {
        for (int i = 0; i < rows; i++) {
            int temp = arr[i][j];
            arr[i][j] = arr[i][cols - j - 1];
            arr[i][cols - j - 1] = temp;
        }
    }
}

void printArray(int arr[][4], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int arr1[][3] = {{1, 2, 3},
                     {4, 5, 6},
                     {7, 8, 9}};

    int arr2[][4] = {{1, 2, 3, 4},
                     {5, 6, 7, 8},
                     {9, 10, 11, 12}};

    int rows1 = sizeof(arr1) / sizeof(arr1[0]);
    int cols1 = sizeof(arr1[0]) / sizeof(arr1[0][0]);

    int rows2 = sizeof(arr2) / sizeof(arr2[0]);
    int cols2 = sizeof(arr2[0]) / sizeof(arr2[0][0]);

    printf("Original Array 1:\n");
    printArray(arr1, rows1, cols1);

    reverseColumns(arr1, rows1, cols1);

    printf("\nArray 1 after reversing columns:\n");
    printArray(arr1, rows1, cols1);

    printf("\nOriginal Array 2:\n");
    printArray(arr2, rows2, cols2);

    shiftColumns(arr2, rows2, cols2);

    printf("\nArray 2 after shifting columns to the left by 2 positions:\n");
    printArray(arr2, rows2, cols2);

    return 0;
}

Zad 5
Napisz program, który działa na liście modyfikując ją w taki sposób, że zwraca listę , składającą się z co drugiego elementu wyjściowej listy, licząc od pierwszego jej elementu; np. dla listy o elementach 1 5 8 7 2, zwraca listę 1 8 2. Zwolnij niewykorzystaną pamięć.

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void addNode(Node** head, int data) {
    Node* newNode = createNode(data);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
}

void freeList(Node** head) {
    Node* current = *head;
    Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    *head = NULL;
}

Node* getAlternateList(Node* head) {
    Node* result = NULL;
    Node* current = head;
    int count = 1;
    while (current != NULL) {
        if (count % 2 == 1) {
            addNode(&result, current->data);
        }
        current = current->next;
        count++;
    }
    return result;
}

void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

int main() {
    Node* head = NULL;
    addNode(&head, 1);
    addNode(&head, 5);
    addNode(&head, 8);
    addNode(&head, 7);
    addNode(&head, 2);

    printf("Original List: ");
    printList(head);

    Node* alternateList = getAlternateList(head);
    printf("Modified List: ");
    printList(alternateList);

    freeList(&head);
    freeList(&alternateList);

    return 0;
}

Zad 6
Napisz program, który działa na liście modyfikując ją w taki sposób, że zwraca listę z usunięciem środkowego elementu bądź elementów. W przypadku gdy liczba elementów listy jest parzysta, należy wyrzucić z niej dwa środkowe elementy, w przeciwnym razie jeden; np. dla listy 5 8 9 1 6, program zwraca 5 8 1 6, a dla listy 1 6 7 5 4 9 program zwraca 1 6 4 9. Zwolnij niewykorzystaną pamięć

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

void insert(Node** head, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;

    if (*head == NULL) {
        *head = newNode;
    } else {
        Node* current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
    }
}

void deleteMiddleElement(Node** head) {
    if (*head == NULL || (*head)->next == NULL) {
        return;
    }

    Node* slowPtr = *head;
    Node* fastPtr = *head;
    Node* prev = NULL;

    while (fastPtr != NULL && fastPtr->next != NULL) {
        fastPtr = fastPtr->next->next;
        prev = slowPtr;
        slowPtr = slowPtr->next;
    }

    if (prev != NULL) {
        prev->next = slowPtr->next;
    } else {
        *head = slowPtr->next;
    }

    free(slowPtr);
}

void freeList(Node** head) {
    Node* current = *head;
    Node* next;

    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }

    *head = NULL;
}

void printList(Node* head) {
    Node* current = head;

    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }

    printf("\n");
}

int main() {
    Node* head = NULL;
    int n, data;

    printf("Podaj liczbe elementow: ");
    scanf("%d", &n);

    printf("Podaj elementy listy:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &data);
        insert(&head, data);
    }

    printf("Lista przed modyfikacja: ");
    printList(head);

    deleteMiddleElement(&head);

    printf("Lista po modyfikacji: ");
    printList(head);

    freeList(&head);

    return 0;
}

Zad 1
Napisz funkcję przelicz, która dostaje jako argumenty dwie tablice znaków i zlicza liczbę wystąpień napisu pierwszego w drugim: np. dla napisów "ma" oraz "mama ma mala marynarke", program zwraca 5. Zliczamy tylko liczbę rozłącznych wystąpień, to znaczy kawałem napisu wykrytego wcześniej nie może tworzyć kawałku napisu, wykrytego później np. napis "nana" w napisie "nanananananabanana", mamy 3 wystąpienia na indeksach 0 -3 4 -7 12 -15. Wynikiem funkcji jest wiec 3.

#include <stdio.h>
#include <string.h>

int przelicz(char* napis1, char* napis2) {
    int count = 0;
    int len1 = strlen(napis1);
    int len2 = strlen(napis2);

    for (int i = 0; i <= len2 - len1; i++) {
        int found = 1; // Flaga wskazująca, czy znaleziono wystąpienie napisu1

        for (int j = 0; j < len1; j++) {
            if (napis2[i + j] != napis1[j]) {
                found = 0;
                break;
            }
        }

        if (found) {
            count++;
            i += len1 - 1; // Pomijamy znaki, które już sprawdziliśmy w tym wystąpieniu
        }
    }

    return count;
}

int main() {
    char napis1[] = "ma";
    char napis2[] = "mama ma mala marynarke";
    int liczbaWystapien = przelicz(napis1, napis2);
    printf("Liczba wystapien: %d\n", liczbaWystapien);

    return 0;
}

Zad 2
Napisać funkcję odwróć, która otrzymuje jako argument tablicę znaków i odwraca kolejność znaków w napisie znajdującym się w tablicy.
Np. wywołanie funkcji dla napisu Master zmieni go na retsaM.

#include <stdio.h>
#include <string.h>

void odwroc(char* napis) {
    int dlugosc = strlen(napis);
    int i, j;

    for (i = 0, j = dlugosc - 1; i < j; i++, j--) {
        char temp = napis[i];
        napis[i] = napis[j];
        napis[j] = temp;
    }
}

int main() {
    char napis[] = "Master";

    printf("Przed: %s\n", napis);
    odwroc(napis);
    printf("Po: %s\n", napis);

    return 0;
}

Zad 3
Napisz funkcję, która otrzymuje w argumencie dodatnią liczbę całkowitą n oraz dwuwymiarową trójkątna tablicę tablic elementów typu unsigned int o rozmiarach n na n. Funkcja ma zwrócić indeks kolumny o maksymalnej średniej arytmetycznej znajdujących się w niej elementów. Jeśli jest kilka takich kolumn to zwrócić indeks dowolnej spośród nich. Np dla tablicy tablic:
4
2 3
1 9 8
2 1 2 3
maksymalna średnia arytmetyczna występuje w kolumnie o indeksie 2.

#include <stdio.h>

int znajdzKolumneOMaksymalnejSredniej(unsigned int n, unsigned int tablica[n][n]) {
    unsigned int maxSuma = 0;  // Suma maksymalna
    int indeksKolumny = -1;    // Indeks kolumny o maksymalnej średniej

    for (unsigned int kolumna = 0; kolumna < n; kolumna++) {
        unsigned int suma = 0;  // Suma elementów w kolumnie

        for (unsigned int wiersz = 0; wiersz < n; wiersz++) {
            suma += tablica[wiersz][kolumna];
        }

        if (suma > maxSuma) {
            maxSuma = suma;
            indeksKolumny = kolumna;
        }
    }

    return indeksKolumny;
}

int main() {
    unsigned int tablica[4][4] = {
        {4},
        {2, 3},
        {1, 9, 8},
        {2, 1, 2, 3}
    };

    unsigned int n = 4;
    int indeksKolumny = znajdzKolumneOMaksymalnejSredniej(n, tablica);

    printf("Indeks kolumny o maksymalnej średniej: %d\n", indeksKolumny);

    return 0;
}

Zad 4
Napisz funkcję, która dostaje jako argumenty tablicę dwuwymiarową o elementach typu int oraz jej wymiary i zmienia kolejność wierszy przesuwając je o dwa w dół w tablicy w taki sposób, że wiersz pierwszy ma się znaleźć na miejscu trzeciego, wiersz drugi na miejscu czwartego itd., natomiast ostatni wiersz ma się znaleźć na miejscu drugiego, a przedostatni na miejscu pierwszego. 

#include <stdio.h>

void shiftRows(int** array, int rows, int cols) {
    // Przesuwanie wierszy o dwa w dół
    int* temp = array[rows - 1];
    for (int i = rows - 1; i > 0; i--) {
        array[i] = array[i - 1];
    }
    array[0] = temp;
}

void printArray(int** array, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", array[i][j]);
        }
        printf("\n");
    }
}

int main() {
    // Przykładowe dane wejściowe
    int rows = 4;
    int cols = 3;
    int** array = malloc(rows * sizeof(int*));
    for (int i = 0; i < rows; i++) {
        array[i] = malloc(cols * sizeof(int));
        for (int j = 0; j < cols; j++) {
            array[i][j] = i * cols + j + 1;
        }
    }

    printf("Tablica przed przesunięciem:\n");
    printArray(array, rows, cols);

    // Przesunięcie wierszy
    shiftRows(array, rows, cols);

    printf("\nTablica po przesunięciu:\n");
    printArray(array, rows, cols);

    // Zwolnienie pamięci
    for (int i = 0; i < rows; i++) {
        free(array[i]);
    }
    free(array);

    return 0;
}

Zad 5
Napisz funkcję, która oblicza średnią arytmetyczną z liczb całkowitych przechowywanych w polach i elementów listy przekazanej w jej argumencie.

#include <stdio.h>

float obliczSrednia(int lista[], int rozmiar) {
    int suma = 0;
    int i;

    for (i = 0; i < rozmiar; i++) {
        suma += lista[i];
    }

    float srednia = (float)suma / rozmiar;
    return srednia;
}

int main() {
    int liczby[] = {5, 10, 15, 20, 25};
    int rozmiar = sizeof(liczby) / sizeof(liczby[0]);

    float srednia = obliczSrednia(liczby, rozmiar);

    printf("Srednia: %.2f\n", srednia);

    return 0;
}

Zad 6
Napisz funkcję, której argumentami są dwie listy. Funkcja tworzy z nich jedną listę w następujący sposób; pierwszym jej elementem jest element pierwszej listy. Później występują elementy z listy drugiej do momentu aż któryś z nich będzie równy pierwszemu elementowi listy pierwszej, dalej elementy pierwszej listy gdy któryś będzie równy któremuś z wcześniej już dopisanych do listy elementów z listy drugiej i tak na przemian. Gdy wyczerpana zostanie któraś z list jako ostatnie elementy dopisujemy po kolej wszystkie niewykorzystane do tej pory elementy z niewyczerpanej listy.
Np. dla list 5 8 9 6 2 oraz 1 6 7 5 4 9 1 2 4 zwrócona ma zostać lista:
5 1 6 7 5 8 9 6 4 9 2 1 2 4. Rozumowanie przy jej tworzeniu wygląda następująco:
najpierw pierwszy element z pierwszej listy 5,
później elementy z drugiej listy aż do momentu pojawienia się 5, czyli 1 6 7 5,
później elementy z pierwszej listy aż do momentu pojawienia się którejś z wartości 1 6 7 5, czyli 8 9 6,
później elementy z drugiej listy aż do momentu pojawienia się którejś z wartości 5 8 9 6, czyli 4 9,
później elementy z pierwszej listy aż do momentu pojawienia się którejś z wartości 1 6 7 5 4 9, czyli 2, co jednocześnie wyczerpuje elementy pierwszej listy,
na koniec wstawiamy wszystkie niewykorzystywane elementy niewyczerpane listy 1 2 4.

#include <stdio.h>
#include <stdlib.h>

int* merge_lists(int* list1, int size1, int* list2, int size2, int* merged_size) {
    int* merged_list = (int*)malloc((size1 + size2) * sizeof(int)); // alokacja pamięci dla scalonej listy
    int index1 = 0; // indeks dla listy pierwszej
    int index2 = 0; // indeks dla listy drugiej
    int merged_index = 0; // indeks dla scalonej listy

    // Dopóki nie wyczerpamy żadnej z list
    while (index1 < size1 && index2 < size2) {
        // Dopóki elementy się różnią, dodajemy kolejne elementy
        while (index1 < size1 && index2 < size2 && list1[index1] != list2[index2]) {
            // Dodajemy elementy z listy pierwszej
            merged_list[merged_index] = list1[index1];
            merged_index++;
            index1++;
        }

        // Dopóki elementy się różnią, dodajemy kolejne elementy
        while (index1 < size1 && index2 < size2 && list1[index1] == list2[index2]) {
            // Dodajemy elementy z listy drugiej
            merged_list[merged_index] = list2[index2];
            merged_index++;
            index2++;
        }
    }

    // Dodajemy pozostałe elementy z listy pierwszej, jeśli istnieją
    while (index1 < size1) {
        merged_list[merged_index] = list1[index1];
        merged_index++;
        index1++;
    }

    // Dodajemy pozostałe elementy z listy drugiej, jeśli istnieją
    while (index2 < size2) {
        merged_list[merged_index] = list2[index2];
        merged_index++;
        index2++;
    }

    *merged_size = merged_index; // zapisujemy rozmiar scalonej listy
    return merged_list;
}

int main() {
    int list1[] = {5, 8, 9, 6, 2};
    int size1 = sizeof(list1) / sizeof(list1[0]);

    int list2[] = {1, 6, 7, 5, 4, 9, 1, 2, 4};
    int size2 = sizeof(list2) / sizeof(list2[0]);

    int merged_size = 0;
    int* merged_list = merge_lists(list1, size1, list2, size2, &merged_size);

    printf("Merged List: ");
    for (int i = 0; i < merged_size; i++) {
        printf("%d ", merged_list[i]);
    }
    printf("\n");

    free(merged_list); // zwalnianie pamięci

    return 0;
}
